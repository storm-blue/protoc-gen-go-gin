package main

import (
	"fmt"
	"net/http"
	"regexp"
	"strings"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	contextPkg         = protogen.GoImportPath("context")
	ginPkg             = protogen.GoImportPath("github.com/gin-gonic/gin")
	metadataPkg        = protogen.GoImportPath("google.golang.org/grpc/metadata")
	deprecationComment = "// Deprecated: Do not use."
)

var methodSets = make(map[string]int)

func getGoPackageName(gen *protogen.Plugin, goImportPath protogen.GoImportPath) protogen.GoPackageName {
	for _, f := range gen.FilesByPath {
		if f.GoImportPath == goImportPath {
			return f.GoPackageName
		}
	}

	panic(fmt.Errorf("no such package: %v", goImportPath))
}

func getFullTypeName(gen *protogen.Plugin, t *protogen.Message, thisFile *protogen.File) string {
	goImportPath := t.GoIdent.GoImportPath
	if thisFile.GoImportPath == goImportPath {
		return t.GoIdent.GoName
	} else {
		goPackageName := getGoPackageName(gen, goImportPath)
		return fmt.Sprintf("%s.%s", goPackageName, t.GoIdent.GoName)
	}
}

// extractComments extracts summary, description, and tags from proto comments.
func extractComments(loc *descriptorpb.SourceCodeInfo_Location) (summary, description, tags string) {
	if loc == nil || loc.LeadingComments == nil || *loc.LeadingComments == "" {
		return "", "", ""
	}

	comments := strings.TrimSpace(*loc.LeadingComments)
	lines := strings.Split(comments, "\n")

	// Clean each line, remove comment symbols and extra spaces
	var cleanLines []string
	for _, line := range lines {
		line = strings.TrimSpace(line)
		// Remove possible comment symbols
		line = strings.TrimPrefix(line, "//")
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "@auth") {
			continue // Skip @auth line
		}
		cleanLines = append(cleanLines, line)
	}

	if len(cleanLines) == 0 {
		return "", "", ""
	}

	// Take the first line as summary
	summary = cleanLines[0]

	// Join all lines as description
	description = strings.Join(cleanLines, " ")

	// Try to extract tags from comments (format: @tag:value)
	for _, line := range cleanLines {
		if strings.HasPrefix(line, "@tag:") {
			tags = strings.TrimPrefix(line, "@tag:")
			break
		}
	}

	return summary, description, tags
}

// getHTTPMethod returns the HTTP method for a method, using rule if present, otherwise fallback to method name.
func getHTTPMethod(rule *annotations.HttpRule, m *protogen.Method) string {
	if rule != nil {
		switch pattern := rule.Pattern.(type) {
		case *annotations.HttpRule_Get:
			return "GET"
		case *annotations.HttpRule_Put:
			return "PUT"
		case *annotations.HttpRule_Post:
			return "POST"
		case *annotations.HttpRule_Delete:
			return "DELETE"
		case *annotations.HttpRule_Patch:
			return "PATCH"
		case *annotations.HttpRule_Custom:
			return pattern.Custom.Kind
		}
	}
	// fallback: method name
	names := strings.Split(toSnakeCase(m.GoName), "_")
	if len(names) == 0 {
		return "POST"
	}
	switch strings.ToUpper(names[0]) {
	case http.MethodGet, "FIND", "QUERY", "LIST", "SEARCH":
		return http.MethodGet
	case http.MethodPost, "CREATE":
		return http.MethodPost
	case http.MethodPut, "UPDATE":
		return http.MethodPut
	case http.MethodPatch:
		return http.MethodPatch
	case http.MethodDelete:
		return http.MethodDelete
	default:
		return "POST"
	}
}

// parseAuthSchemes extracts all @auth schemes from comment lines, panics if any @auth is empty.
func parseAuthSchemes(lines []string, level string) []string {
	var schemes []string
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "@auth") {
			scheme := strings.TrimSpace(strings.TrimPrefix(line, "@auth"))
			if scheme == "" {
				panic(fmt.Sprintf("@auth must specify scheme at %s level", level))
			}
			schemes = append(schemes, scheme)
		}
	}
	return schemes
}

// generateFile generates a _gin.pb.go file.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}

	needImport := map[string]struct{}{}
	for _, d := range file.Proto.Dependency {
		df := gen.FilesByPath[d]
		if df != nil {
			needImport[string(df.GoImportPath)] = struct{}{}
		}
	}

	filename := file.GeneratedFilenamePrefix + "_gin.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by github.com/mohuishou/protoc-gen-go-gin. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the protoc-gen-go-gin package it is being compiled against.")

	// Determine whether to import unicode
	needUnicode := false
	for _, s := range file.Services {
		for _, m := range s.Methods {
			method := getHTTPMethod(nil, m) // Pass nil for rule
			if method == "GET" || method == "DELETE" {
				needUnicode = true
				break
			}
		}
		if needUnicode {
			break
		}
	}

	g.P("import (")
	g.P(contextPkg)
	g.P(ginPkg)
	if needUnicode {
		g.P("\"unicode\"")
	}
	for pkg, _ := range needImport {
		g.P(protogen.GoImportPath(pkg))
	}
	g.P(metadataPkg)
	g.P(")")
	g.P()

	for _, s := range file.Services {
		genService(gen, file, g, s)
	}
	return g
}

// genService passes service-level @auth
func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, s *protogen.Service) {
	if s.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	sd := &service{
		Name:     s.GoName,
		FullName: string(s.Desc.FullName()),
		FilePath: file.Desc.Path(),
	}
	// Extract service-level @auth
	if file.Proto.SourceCodeInfo != nil {
		for _, loc := range file.Proto.SourceCodeInfo.Location {
			if len(loc.Path) == 2 && loc.Path[0] == 6 && int(loc.Path[1]) == int(s.Desc.Index()) {
				if loc.LeadingComments != nil && *loc.LeadingComments != "" {
					lines := strings.Split(*loc.LeadingComments, "\n")
					schemes := parseAuthSchemes(lines, "service")
					if len(schemes) > 0 {
						sd.DefaultAuth = true
						sd.DefaultAuthSchemes = strings.Join(schemes, ",")
					}
				}
			}
		}
	}
	for _, m := range s.Methods {
		mds := buildMethod(gen, m, file, sd)
		sd.Methods = append(sd.Methods, mds...)
	}
	g.P(sd.execute())
}

// buildMethod handles both HTTP rule and default method, and applies service-level auth inheritance
func buildMethod(gen *protogen.Plugin, m *protogen.Method, thisFile *protogen.File, sd *service) []*method {
	var methods []*method
	rule, ok := proto.GetExtension(m.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
	if rule != nil && ok {
		for _, bind := range rule.AdditionalBindings {
			methods = append(methods, buildMethodDesc(gen, m, getHTTPMethod(bind, m), getPathFromRuleInline(bind), thisFile, sd))
		}
		methods = append(methods, buildMethodDesc(gen, m, getHTTPMethod(rule, m), getPathFromRuleInline(rule), thisFile, sd))
		return methods
	}
	// fallback: default method
	names := strings.Split(toSnakeCase(m.GoName), "_")
	var (
		paths      []string
		httpMethod string
		path       string
	)
	httpMethod = getHTTPMethod(nil, m)
	if httpMethod == "POST" {
		paths = names
	}
	if len(paths) > 0 {
		path = strings.Join(paths, "/")
	}
	if len(names) > 1 {
		path = strings.Join(names[1:], "/")
	}
	methods = append(methods, buildMethodDesc(gen, m, httpMethod, path, thisFile, sd))
	return methods
}

// getPathFromRuleInline extracts path from HttpRule (inlined, not global)
func getPathFromRuleInline(rule *annotations.HttpRule) string {
	switch pattern := rule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		return pattern.Get
	case *annotations.HttpRule_Put:
		return pattern.Put
	case *annotations.HttpRule_Post:
		return pattern.Post
	case *annotations.HttpRule_Delete:
		return pattern.Delete
	case *annotations.HttpRule_Patch:
		return pattern.Patch
	case *annotations.HttpRule_Custom:
		return pattern.Custom.Path
	}
	return ""
}

// buildMethodDesc extracts comments, handles @auth inheritance, and builds method struct.
func buildMethodDesc(gen *protogen.Plugin, m *protogen.Method, httpMethod, path string, thisFile *protogen.File, sd *service) *method {
	// Use static methodSets map for method index
	var methodSetsLocal = methodSets
	defer func() { methodSetsLocal[m.GoName]++ }()
	// Extract comments (summary/desc/tags)
	summary, description, tags := "", "", ""
	deprecated := false
	requireAuth := false
	authSchemes := ""
	// Method-level @auth
	if thisFile.Proto.SourceCodeInfo != nil {
		for _, loc := range thisFile.Proto.SourceCodeInfo.Location {
			if len(loc.Path) >= 4 && loc.Path[0] == 6 && loc.Path[2] == 2 && int(loc.Path[3]) == int(m.Desc.Index()) {
				summary, description, tags = extractComments(loc)
				if loc.LeadingComments != nil && *loc.LeadingComments != "" {
					lines := strings.Split(*loc.LeadingComments, "\n")
					schemes := parseAuthSchemes(lines, "method")
					if len(schemes) > 0 {
						requireAuth = true
						authSchemes = strings.Join(schemes, ",")
					}
				}
				break
			}
		}
	}
	// Inherit service-level @auth if method-level not set
	if !requireAuth && sd.DefaultAuth {
		requireAuth = true
		authSchemes = sd.DefaultAuthSchemes
	}
	if m.Desc.Options() != nil {
		deprecated = m.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated()
	}
	md := &method{
		Name:        m.GoName,
		Num:         methodSetsLocal[m.GoName],
		Path:        path,
		Method:      httpMethod,
		Request:     getFullTypeName(gen, m.Input, thisFile),
		Reply:       getFullTypeName(gen, m.Output, thisFile),
		Summary:     summary,
		Description: description,
		Tags:        tags,
		Deprecated:  deprecated,
		RequireAuth: requireAuth,
		AuthSchemes: authSchemes,
	}
	md.initPathParams()
	return md
}

var matchFirstCap = regexp.MustCompile("([A-Z])([A-Z][a-z])")
var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

func toSnakeCase(input string) string {
	output := matchFirstCap.ReplaceAllString(input, "${1}_${2}")
	output = matchAllCap.ReplaceAllString(output, "${1}_${2}")
	output = strings.ReplaceAll(output, "-", "_")
	return strings.ToLower(output)
}
